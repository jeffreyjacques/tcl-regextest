#!/usr/bin/env wish# regextest.tcl --
#
# UI generated by GUI Builder Build 146 on 2008-10-17 11:11:58 from:
#    /home/tmp/jeff/regextest.ui
# This file is auto-generated.  Only the code within
#    '# BEGIN USER CODE'
#    '# END USER CODE'
# and code inside the callback subroutines will be round-tripped.
# The proc names 'ui' and 'init' are reserved.
#

package require Tk 8.4

# Declare the namespace for this dialog
namespace eval regextest {}

# Source the ui file, which must exist
set regextest::SCRIPTDIR [file dirname [info script]]
source [file join $regextest::SCRIPTDIR regextest_ui.tcl]

# BEGIN USER CODE
set regex ""

proc Run {} {
	global regex
	set text "._text_string"
	set info "._text_info"
	set entry_rgx "._entry_regex"
	set line ""


	bind $entry_rgx <Return> Run

	# get the text and remove an exraneous newline
	set line [$text get 1.0 end]
	set line [string trimright $line "\n"]

	set indices {}
	set open_char_set 0
	set last_val ""
	set bkslh_cnt 0
	# here we figure out how many substring matches are present
	for {set i 0} {$i < [string length $regex]} {incr i} {
		set cur_val [string index $regex $i]
		set next2vals [string index $regex [expr {$i + 1}]]
		set next2vals $next2vals[string index $regex [expr {$i + 2}]]
		# switch block to ensure we don't select open parens that
		# are inside a character set or noncapture syntax follows
		switch -exact -- $cur_val {
			[ {if {[expr $bkslh_cnt % 2] == 0} {set open_char_set 1} }
			] { if {$last_val ne {[}} {set open_char_set 0} }
			{(} { if {!$open_char_set && $next2vals ne {?:}} {lappend indices $i} }
			\\ { incr bkslh_cnt }
		}
		if { $cur_val ne "\\" } {
			set bkslh_cnt 0
		}
		set last_val $cur_val
	}

	# set up a list of variable names for pattern match and each substring
	set matchvars {sub0}
	set i 1
	foreach index $indices {
		lappend matchvars sub$i
		incr i
	}

	# create the regex command
	set cmd "[list regexp -- $regex $line] $matchvars"
	# unlock the info field and erase
	$info configure -state normal
	$info delete 1.0 end
	# run the regex and update display with results
	if [catch {eval $cmd} ret] {
		$text tag remove sel 1.0 end
		$text configure -foreground black
		set info_msg "Error running regexp:\n$ret"
		$info insert insert $info_msg
	} elseif { $ret } {
		$text tag remove sel 1.0 end
		$text configure -foreground black
		set cnt "0"
		set start [$text search -count cnt -regexp -- $regex 1.0 end]
		$text tag add sel $start "$start +$cnt chars"
		$text tag configure sel -background green
		set info_msg "Match found!\n"
		foreach var $matchvars {
			set info_msg "${info_msg}$var: \"[eval {set $var}]\"\n"
		}
		$info insert insert $info_msg
	} else {
		$text tag remove sel 1.0 end
		$text configure -foreground red
		set info_msg "No match found."
		$info insert insert $info_msg
	}
	# relock the info field
	$info configure -state disabled

	set _done 0
	tkwait variable _done
	update

}
# END USER CODE

# BEGIN CALLBACK CODE
# ONLY EDIT CODE INSIDE THE PROCS.

# regextest::_entry_regex_invalidcommand --
#
# Callback to handle _entry_regex widget option -invalidcommand
#
# ARGS:
#    <NONE>
#
proc regextest::_entry_regex_invalidcommand args {}

# regextest::_entry_regex_validatecommand --
#
# Callback to handle _entry_regex widget option -validatecommand
#
# ARGS:
#    <NONE>
#
proc regextest::_entry_regex_validatecommand args {}

# regextest::_entry_regex_xscrollcommand --
#
# Callback to handle _entry_regex widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc regextest::_entry_regex_xscrollcommand args {}

# regextest::_text_info_xscrollcommand --
#
# Callback to handle _text_info widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc regextest::_text_info_xscrollcommand args {}

# regextest::_text_info_yscrollcommand --
#
# Callback to handle _text_info widget option -yscrollcommand
#
# ARGS:
#    <NONE>
#
proc regextest::_text_info_yscrollcommand args {}

# regextest::_text_string_xscrollcommand --
#
# Callback to handle _text_string widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc regextest::_text_string_xscrollcommand args {}

# regextest::_text_string_yscrollcommand --
#
# Callback to handle _text_string widget option -yscrollcommand
#
# ARGS:
#    <NONE>
#
proc regextest::_text_string_yscrollcommand args {}

# regextest::_button_1_command --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_button_1_command args {}

# regextest::_button_2_command --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_button_2_command args {}

# regextest::_button_run_command --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_button_run_command args {}

# regextest::_Entry_1_command --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_Entry_1_command args {}

# regextest::_Entry_1_invalidcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_Entry_1_invalidcommand args {}

# regextest::_entry_1_invalidcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_entry_1_invalidcommand args {}

# regextest::_Entry_1_validatecommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_Entry_1_validatecommand args {}

# regextest::_entry_1_validatecommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_entry_1_validatecommand args {}

# regextest::_Entry_1_xscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_Entry_1_xscrollcommand args {}

# regextest::_entry_1_xscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_entry_1_xscrollcommand args {}

# regextest::_string_text_xscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_string_text_xscrollcommand args {}

# regextest::_string_text_yscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_string_text_yscrollcommand args {}

# regextest::_text_1_xscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_text_1_xscrollcommand args {}

# regextest::_text_1_yscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_text_1_yscrollcommand args {}

# regextest::_text_3_xscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_text_3_xscrollcommand args {}

# regextest::_text_3_yscrollcommand --
#
# Legacy command found in callback code. Add user comments inside body.
#
# ARGS:
#    <NONE>
#
proc regextest::_text_3_yscrollcommand args {}

# END CALLBACK CODE

# regextest::init --
#
#   Call the optional userinit and initialize the dialog.
#   DO NOT EDIT THIS PROCEDURE.
#
# Arguments:
#   root   the root window to load this dialog into
#
# Results:
#   dialog will be created, or a background error will be thrown
#
proc regextest::init {root args} {
    # Catch this in case the user didn't define it
    catch {regextest::userinit}
    if {[info exists embed_args]} {
	# we are running in the plugin
	regextest::ui $root
    } elseif {$::argv0 == [info script]} {
	# we are running in stand-alone mode
	wm title $root regextest
	if {[catch {
	    # Create the UI
	    regextest::ui  $root
	} err]} {
	    bgerror $err ; exit 1
	}
    }
    catch {regextest::run $root}
}
regextest::init .

